---
title: "Causal effects of religious service attendance on cooperation"
subtitle: "An outcomewide approach"
abstract: |
  Counterfactual Prediction
author: 
  - name: Joseph A. Bulbulia
    affiliation: Victoria University of Wellington, New Zealand
    orcid_id: 0000-0002-5861-2056
    email: joseph.bulbulia@vuw.ac.nz
    corresponding: yes
  - name: Don E Davis
    affiliation: Georgia State University
    orcid_id: 0000-0003-3169-6576 
  - name: Ken Rice
    affiliation: Georgia State University 
  - name: Geoffrey Troughton
    affiliation: Victoria University of Wellington
  - name: Chris G. Sibley
    affiliation: School of Psychology, University of Auckland
    orcid_id: 0000-0002-4064-8800
execute:
  warning: false
  eval: false
keywords:
  - measurement
date: last-modified
editor_options: 
  chunk_output_type: console
---

```{r}
#| label: load-libraries
#| echo: false
#| include: true
#| eval: true

# uncomment and use these links to load your functions
# source("https://raw.githubusercontent.com/go-bayes/templates/main/functions/libs2.R")

# # read functions
# source("https://raw.githubusercontent.com/go-bayes/templates/main/functions/funs.R")

# for latex graphs
# for making graphs
library("tinytex")
library(extrafont)
loadfonts(device = "all")

### ALWAYS RESTART R IN A FRESH SESSION ####

# libraries for jb (when internet is not accessible)
# read libraries
source("/Users/joseph/GIT/templates/functions/libs2.R")

# read functions
source("/Users/joseph/GIT/templates/functions/funs.R")

# experimental functions (more functions)
# source(
#   "https://raw.githubusercontent.com/go-bayes/templates/main/functions/experimental_funs.R"
# )


# read data/ set to path in your computer
pull_path <-
  fs::path_expand(
    "/Users/joseph/v-project\ Dropbox/data/current/nzavs_13_arrow"
  )

dat <- arrow::read_parquet("/Users/joseph/v-project\ Dropbox/Joseph\ Bulbulia/00Bulbulia\ Pubs/DATA/nzavs_refactor/nzavs_data_23"))

# for saving models. # set path fo your computer
push_mods <-  fs::path_expand(
    "/Users/joseph/v-project\ Dropbox/data/nzvs_mods/00drafts/23-ow-coop-church-lmtp"
  )

# read data: note that you need use the arrow package in R
dat <- arrow::read_parquet(pull_path)

# check path:is this correct?  check so you know you are not overwriting other directors
push_mods
install_cmdstan(cores = 2)

nzavs_exposure<- "religion_church_round"
# 
# library(future)
# library(future.apply)
# #parallelize and fix multithreading
# progressr::handlers(global = TRUE)
# if (availableCores() < 10L) {
#   plan(multicore)
# } else {
#   # NOTE: bookkeeping for future topologies
#   plan(list(
#     tweak(multicore, workers = availableCores() %/% SL_folds),
#     tweak(multicore, workers = SL_folds - 1L)
#   ))
# }
# openblasctl::openblas_set_num_threads(1L)
# OpenMPController::omp_set_num_threads(1L)
# 
# set.seed(0112358)








```

```{r}

#| label: clean data
#| echo: false
#| include: false
#| eval: false

# HFRDTJ	Hours.Friends.T10	Hours - Socialising with friends
# HFAMTJ	Hours.Family.T10	Hours - Socialising with family
# HCOMTJ	Hours.Community.T10	Hours - Socialising with community groups

table1::table1(~hours_community | wave, data = dat)
table(dat$hours_community)
table1::table1(~hours_family | wave, data = dat)
table(dat$hours_family)

table(dat$hours_family)
hist(sqrt( dat$hours_friends))
hist(sqrt( dat$religion_church))


dat_long  <- dat |> 
 # filter(id %in% religious_ids) %>%
  arrange(id, wave) |>
  mutate(urban = factor(
    ifelse(
      rural_gch2018 == "Medium Urban Accessibility" |
        # Define urban condition
        rural_gch2018 == "High Urban Accessibility",
      "urban",
      # Label 'urban' if condition is met
      "rural"  # Label 'rural' if condition is not met
    )
  )) |>
  # select variables
  # mutate(across(where(is.double), as.numeric)) |>
  mutate(
    hours_community_sqrt_raw = sqrt(hours_community),
    hours_friends_sqrt_raw = sqrt(hours_friends),
    hours_family_sqrt_raw = sqrt(hours_family)
  ) |>
    mutate(
    hours_community_sqrt_round = ifelse(hours_community_sqrt_raw >= 8, 8,hours_community_sqrt_raw),
    hours_friends_sqrt_round = ifelse(hours_friends_sqrt_raw >= 8, 8,hours_friends_sqrt_raw),
    hours_family_sqrt_round = ifelse(hours_family_sqrt_raw >= 8, 8,hours_family_sqrt_raw),
  ) |>
  mutate(male = as.numeric(male) - 1) |>
  mutate(total_siblings_factor = ordered(round(ifelse(total_siblings > 7, 7, total_siblings), 0))) |> 
  rename(religion_religious = religious) |>  # religious yes/no
  mutate(religion_prayer_binary = ifelse(religion_prayer > 0, 1, 0)) |>
  mutate(religion_church_binary = ifelse(religion_church > 0, 1, 0)) |>
  mutate(religion_church_f = ifelse(religion_church >= 21, 21, 0)) |>
  mutate(religion_scripture_binary = ifelse(religion_scripture > 0, 1, 0)) |>
  mutate(religion_religious = as.numeric(religion_religious) - 1) |>
  mutate(
    religion_church_round = round( ifelse(religion_church >=8, 8, religion_church), 0) )|> 
  mutate(hours_community_round = round(ifelse(hours_community >=24, 24, hours_community), 0) )|> 
  mutate(
    eth_cat = as.integer(eth_cat),
    urban = as.numeric(urban),
    education_level_coarsen = as.integer(education_level_coarsen)
  ) |>
 dplyr::filter((wave == 2018 & year_measured  == 1) |
                  (wave == 2019  &
                     year_measured  == 1) |
                  (wave == 2020 )) |>  # Eligibility criteria  Observed in 2018/2019 & Outcomes in 2020 or 2021
  group_by(id) |>
  dplyr::mutate(meets_criteria_baseline = ifelse(year_measured == 1 &!is.na(!!sym(nzavs_exposure))&!is.na(hours_community_sqrt_raw), 1, 0)) |>  # using R lang
  dplyr::mutate(sample_origin = sample_origin_names_combined) |>  #shorter name
  arrange(id) |>
  filter((wave == 2018 & year_measured == 1) |
           (wave == 2019 & year_measured == 1) |
           (wave == 2020)) %>%
  group_by(id) |> 
  mutate(k_18 = ifelse(wave == 2018 &  meets_criteria_baseline == 1, 1, 0)) %>% # selection criteria
  mutate(h_18 = mean(k_18, na.rm = TRUE)) %>%
  mutate(k_19 = ifelse(wave == 2019 & meets_criteria_baseline == 1, 1,0)) %>% # selection criteria
  mutate(h_19 = mean(k_19, na.rm = TRUE)) %>%
  dplyr::filter(h_18 > 0) |>  # hack to enable repeat of baseline
  dplyr::filter(h_19 > 0) |>  # hack to enable repeat of baseline
  ungroup() %>%
    mutate(
    not_censored = ifelse(lead(year_measured) == 1, 1, 0),
    # not_censored = ifelse(lead(year_measured)== -1, 0, not_censored,
    # not_censored = ifelse(lead(year_measured) == 0, 0, not_censored,
    not_censored = ifelse(is.na(not_censored) &
                            year_measured == 1, 1, not_censored),
    not_censored = ifelse(is.na(not_censored), 0, not_censored)

  ) |>
  ungroup() |> 
   dplyr::mutate(
    friends_money = ifelse(friends_money < 0, 0, friends_money), # someone gave neg number
    household_inc_log = log(household_inc + 1),
    hours_children_log = log(hours_children + 1),
    hours_work_log = log(hours_work + 1),
    hours_housework_log = log(hours_housework + 1),
  ) |> 
  dplyr::rename(sample_weights = w_gend_age_euro) |>
  dplyr::mutate(sample_origin = sample_origin_names_combined) |>  #shorter name
  arrange(id, wave) |> 
  droplevels() |> 
  select(-h_18,-k_18,-h_19,-k_19) |> 
  data.frame() |> 
  droplevels() |>
  arrange(id, wave) |>
  #   mutate(
  #   religion_church_coarsen = cut(
  #     religion_church,
  #     breaks = c(-Inf, 0, 1, 3.99, Inf),
  #     labels = c("zero", "one", "less_four", "four_up"),
  #     include.lowest = TRUE,
  #     right = TRUE,
  #     ordered = TRUE
  #   )
  # ) %>%
  # mutate(
  #   religion_church_coarsen_n = as.numeric(religion_church_coarsen) - 1,
  #   religion_church_binary_n = as.numeric(religion_church_binary)
  # ) |>
  mutate(
    # religion_church_binary = as.factor(religion_church_binary),
    # eth_cat = as.integer(eth_cat),
    urban = as.numeric(urban),
    education_level_coarsen = as.integer(education_level_coarsen)
  ) |>
  droplevels() |>
  arrange(id, wave) |>
  data.frame()
#
n_unique(dat_long$id) #33198 # reports hours with community at baseline
dat_long$hours_family_sqrt_round
# double check path
push_mods

baseline_vars = c(
  "male",
  "age",
  "education_level_coarsen", # factors
  "eth_cat", #factor(EthCat, labels = c("Euro", "Maori", "Pacific", "Asian")),
  # "employed", # Are you currently employed? (this includes self-employment or casual work)
  #"gen_cohort", #age
 # "bigger_doms",
  "nz_dep2018",
  "nzsei13",
  "total_siblings_factor", # added: needed because we are dealing with family giving/receiving
  "born_nz",  # added
  "hlth_disability",  # added
  "hlth_bmi",
  "household_inc_log", # added: measured with error but OK for imputations
  "partner",
  # "parent",  # newly changed - have information in child number
  "pol_orient", #Please rate how politically liberal versus conservative you see yourself as being.
  "sample_origin",    # Sample origin names combined
  "urban",
  "children_num",
  "household_inc_log", # new from previous study. needed because we are dealing with family giving/receiving
  "hours_children_log", # new
  "hours_work_log", # new
  "hours_housework_log", #new
  "agreeableness",
  "conscientiousness",
  "extraversion",
  "honesty_humility",
  "openness",
  "neuroticism",
  "modesty", # I want people to know that I am an important person of high status, I am an ordinary person who is no better than others. , I wouldnâ€™t want people to treat me as though I were superior to them. I think that I am entitled to more respect than the average person is.
  # "religion_religious", # Do you identify with a religion and/or spiritual group?
  # "religion_identification_level", #How important is your religion to how you see yourself?"  # note this is not a great measure of virtue, virtue is a mean between extremes.
 "religion_church_round", # for prediction
 # "religion_religious", # perfectly colinear
 # "religion_spiritual_identification",
 #  "religion_identification_level",
 #  "religion_religious",
 #  "religion_church_binary",
 #  "religion_prayer_binary",
 #  "religion_scripture_binary",
 #  "religion_believe_god",
 # "religion_believe_spirit",
 "hours_family_sqrt_round",
 "hours_friends_sqrt_round",
 "hours_community_sqrt_round",
 "sample_weights",
 "alert_level_combined_lead" # lead to make it 2019
)
# check
baseline_vars

# check
baseline_vars

# set exposure variable, can be both the continuous and the coarsened, if needed
exposure_var = c("religion_church_round","not_censored","hours_community_sqrt_round") # 


# set outcomes for prosocial domain
outcome_vars = c(
"modesty",
"honesty_humility",
"vengeful_rumin",
"gratitude",
"hours_charity",
"charity_donate",
 "warm_asians",
    "warm_chinese",
   # "warm_disabled" , not at time 10
    # begins w9
    "warm_immigrants",
    "warm_indians",
    "warm_elderly",
    # warm_lgbtq starts w12
    "warm_maori",
    "warm_mental_illness",
    "warm_muslims",
    "warm_nz_euro",
    "warm_overweight",
    "warm_pacific",
    "warm_refugees",
    "religion_perceive_religious_discrim",
    "family_time",
    "friends_time",
    "community_time",
    "support"
    # "support_help",
    # # 'There are people I can depend on to help me if I really need it.
    # "support_turnto",
    # # There is no one I can turn to for guidance in times of stress.
    # "support_rnoguidance"
    # #There is no one I can turn to for guidance in times of stress.
)

dat_long$hours_community_sqrt_round
# impute baseline data (we use censoring for the outcomes)
prep_coop_all <- margot_wide_impute_baseline(
dat_long,
baseline_vars = baseline_vars,
exposure_var = exposure_var,
outcome_vars = outcome_vars
)

here_save(prep_coop_all, "prep_coop_all")

naniar::vis_miss(prep_coop_all, warn_large_data = FALSE)


#check must be a dataframe
str(prep_coop_all)
nrow(prep_coop_all)
# spit and shine
df_wide_censored <-
  prep_coop_all |>
  select(-t1_hours_community_sqrt_round) |>  # exposure for negative control model
  mutate(
    t0_eth_cat = as.factor(t0_eth_cat),
    t2_family_time_binary = as.integer(ifelse(t2_family_time > 0, 1, 0)),
    t2_friends_time_binary = as.integer(ifelse(t2_friends_time > 0, 1, 0)),
    t2_community_time_binary = as.integer(ifelse(t2_community_time > 0, 1, 0))
  ) |>
  relocate("t0_not_censored", .before = starts_with("t1_"))  %>%
  relocate("t1_not_censored", .before = starts_with("t2_"))
    

# save
here_save(df_wide_censored, "df_wide_censored")


# spit and shine
df_clean <- df_wide_censored %>%
  mutate(t2_na_flag = rowSums(is.na(select(
    ., starts_with("t2_")
  ))) > 0) %>%
  mutate(t1_not_censored = ifelse(t2_na_flag, 0, t1_not_censored)) %>%
  # select(-t2_na_flag) %>%
  filter(!rowSums(is.na(select(
    ., starts_with("t0_")
  )))) |>
  dplyr::mutate(
    across(
      where(is.numeric) &
        !t0_not_censored &
        !t1_not_censored &
        !t0_hours_family_sqrt_round &
        !t0_hours_friends_sqrt_round &
        !t0_hours_community_sqrt_round &
        !t0_sample_weights &
        !t1_religion_church_round &
        !t2_charity_donate &
        !t2_family_time_binary &
        !t2_friends_time_binary &
        !t2_community_time_binary &
        !t2_gratitude &
        !t2_hours_charity,
      ~ scale(.x),
      .names = "{col}_z"
    )
  ) |>
  select(
    where(is.factor),
    t0_not_censored,
    t0_hours_family_sqrt_round,
    t0_hours_friends_sqrt_round,
    t0_hours_community_sqrt_round,
    t0_sample_weights,
    t1_not_censored,
    t1_religion_church_round,
    t2_gratitude,
    t2_charity_donate,
    t2_hours_charity,
    t2_family_time_binary,
    t2_friends_time_binary,
    t2_community_time_binary,
    ends_with("_z")
  ) |>
  relocate(starts_with("t0_"), .before = starts_with("t1_"))  %>%
  relocate(starts_with("t2_"), .after = starts_with("t1_"))  %>%
  relocate("t0_not_censored", .before = starts_with("t1_"))  %>%
  relocate("t1_not_censored", .before = starts_with("t2_")) |>
  mutate(t0_sample_weights = as.numeric(t0_sample_weights)) |>
  data.frame()

naniar::vis_miss(df_clean, warn_large_data = FALSE)
#dev.off()

table(df_clean$t2_community_time_binary)
# save data
push_mods
here_save(df_clean,"df_clean")
df_clean <-here_read("df_clean")

colnames(df_clean)
# get names
names_base <- df_clean |> select( starts_with("t0"), - t0_sample_weights,-t0_not_censored )|> colnames()
names_outcomes <- df_clean|> select( starts_with("t2"))|> colnames()

# check
# names_base
# names_outcomes

# exposure_varX1
outcome_vars



#  model
A <- c( "t1_religion_church_round")
C <- c( "t1_not_censored")

#L <- list(c("L1"), c("L2")) 
W <- c(paste(names_base, collapse = ", "))

# check 
print(W) 


#baseline confounders
#L <- as.list(names_base)
table(df_clean$t1_religion_church_round)

# shift function -- what if everyone increased by .5 standard deviation, except those above 2 

# simple shift, everyone goes to church at least 4 times per week
f <- function(data, trt){
  ifelse( data[[trt]] <=4, 4,  data[[trt]] )
}

# f_1 <- function (data, trt) data[[trt]] + 1
 

# Create a vector indicating what algorithms should be R. # used in the SuperLearner 

# libraries
library(SuperLearner)
library(xgboost)
listWrappers()


# "SL.earth" refers to a wrapper for the 'earth' function from the 'earth' R package in the SuperLearner library. This function implements Multivariate Adaptive Regression Splines (MARS), a non-parametric regression method that extends linear models by allowing for interactions and non-linear relationships between variables.
# MARS models can handle high-dimensional data well and can be a useful tool for capturing complex patterns in the data. They work by fitting piecewise linear models to the data, which allows for flexible and potentially non-linear relationships between predictors and the outcome.

# super learner libraries
sl_lib <- c("SL.glmnet", 
           "SL.ranger", # faster implementation of random forest
           "SL.earth") #


# BONUS: progressr progress bars!
progressr::handlers(global = TRUE)

# we will only assess behaviour 
names_outcomes
# recomend tmle for single time point
# recommend sdr for multiple time points
f
A
C


# model charitable giving in population 
m_hours_charity <- lmtp_tmle(
  data = df_clean,
  trt = A,
  baseline = names_base,
  outcome = "t2_hours_charity",
  cens = C,
  shift = f,
  mtp = TRUE,
  folds = 5,
  # trim = 0.99, # if needed
  # time_vary = NULL,
  outcome_type = "continuous",
  #  id = "id",
  weights = df_clean$t0_sample_weights,
  learners_trt = sl_lib,
  learners_outcome = sl_lib 
)
m_hours_charity
here_save(m_hours_charity, "m_hours_charity")
m_hours_charity <- here_read("m_hours_charity")

m_hours_charity_null <- lmtp_tmle(
  data = df_clean,
  trt = A,
  baseline = names_base,
  outcome = "t2_hours_charity",
  cens = C,
  shift = NULL,
 # mtp = TRUE,
  folds = 5,
  # trim = 0.99, # if needed
  # time_vary = NULL,
  outcome_type = "continuous",
  #  id = "id",
  weights = df_clean$t0_sample_weights,
  learners_trt = sl_lib,
  learners_outcome = sl_lib 
)
m_hours_charity_null
here_save(m_hours_charity_null, "m_hours_charity_null")
m_hours_charity_null <- here_read( "m_hours_charity_null")

# caluclate contrast 
contrast_hours_full <- lmtp_contrast(m_hours_charity,ref = m_hours_charity_null, type = "additive")
str(contrast_hours_full)
contrast_hours_full
# 
# min_wage_2022 = 21.20
# nz_adult_population = 3989000
# 
# hours_amount = .406 *min_wage_2022
# hours_amount
# year_hours = hours_amount * 52
# year_hours
# sum_hours = year_hours * nz_adult_population
# 
# sum_hours 
# sum_hours/(nz_annual_budget*4)
# 
# 0.007698764
# 
# # nz annual budget in 2021
# nz_annual_budget = 14494000000 * 4
# nz_annual_budget
# 1,785,374,282
# 
# charity_year = 1715270000
# hours_year = 1785374282
# 
# charity_year/nz_annual_budget
# (charity_year +hours_year)/nz_annual_budget


# not right
church_four <- format_tab_tmle(church_four, scale = "RD", new_name = "church_four")
church_four

# 
# margot_tab_lmtp <- function(tmtp_output, scale = c("RD", "RR"), new_name = "character_string") {
# 
#   scale <- match.arg(scale)
# 
#   require(dplyr)
# 
#   tab_tmle <- cbind.data.frame(
#     tmtp_output$vals$theta,
#     tmtp_output$vals$std.error,
#     tmtp_output$vals$conf.low,
#     tmtp_output$vals$conf.high
#   )
# 
#   if (scale == "RD") {
#     colnames(tab_tmle) <- c("E[Y(1)]-E[Y(0)]", "standard_error", "2.5 %", "97.5 %")
#   } else if (scale == "RR") {
#     colnames(tab_tmle) <- c("E[Y(1)]/E[Y(0)]", "standard_error", "2.5 %", "97.5 %")
#   }
# 
#   tab_tmle_round <- tab_tmle |>
#     dplyr::mutate(across(where(is.numeric), round, digits = 4))
# 
#   rownames(tab_tmle_round)[1] <- paste0(new_name)
# 
#   return(tab_tmle_round)
# }

# 
# theta <- contrast_hours_full$vals$theta
# # adult population
# nz_adult_population = 3989000
# 
# # min wage workers 
# min_wage_2023 = 22.70
# 
# # off the cuff
# hours_volunteering_gained = theta * nz_adult_population
# hours_volunteering_gained
# 
# # cash value of intervention
# hours_volunteering_gained * min_wage_2022
# 
# 
# ## donation model 
# t2_charity_donate

m_charity_donate <- lmtp_tmle(
  data = df_clean,
  trt = A,
  baseline = names_base,
  outcome = "t2_charity_donate",
  cens = C,
  shift = f,
  mtp = TRUE,
  folds = 5,
  # trim = 0.99, # if needed
  # time_vary = NULL,
  outcome_type = "continuous",
  #  id = "id",
  weights = df_clean$t0_sample_weights,
  learners_trt = sl_lib,
  learners_outcome = sl_lib 
)
here_save(m_charity_donate, "m_charity_donate")
m_charity_donate <- here_read("m_charity_donate")

# under null
m_charity_donate_null <- lmtp_tmle(
  data = df_clean,
  trt = A,
  baseline = names_base,
  outcome = "t2_charity_donate",
  cens = C,
  shift = NULL,
  mtp = FALSE,
  folds = 5,
  # trim = 0.99, # if needed
  # time_vary = NULL,
  outcome_type = "continuous",
  #  id = "id",
  weights = df_clean$t0_sample_weights,
  learners_trt = sl_lib,
  learners_outcome = sl_lib 
)

here_save(m_charity_donate_null, "m_charity_donate_null")
m_charity_donate_null <- here_read("m_charity_donate_null")

m_charity_donate_null
contrast_donate_full <- lmtp_contrast(m_charity_donate_null,ref = m_charity_donate_null, type = "additive")
contrast_donate_full


m_time_community <- lmtp_tmle(
  data = df_clean,
  trt = A,
  baseline = names_base,
  outcome = "t2_community_time_binary",
  cens = C,
  shift = f,
  mtp = TRUE,
  folds = 5,
  # trim = 0.99, # if needed
  # time_vary = NULL,
  outcome_type = "binomial",
  #  id = "id",
  weights = df_clean$t0_sample_weights,
  learners_trt = sl_lib,
  learners_outcome = sl_lib 
)
m_time_community
here_save(m_time_community, "m_time_community")

m_time_community_null <- lmtp_tmle(
  data = df_clean,
  trt = A,
  baseline = names_base,
  outcome = "t2_community_time_binary",
  cens = C,
  shift = NULL,
  mtp = FALSE,
  folds = 5,
  # trim = 0.99, # if needed
  # time_vary = NULL,
  outcome_type = "binomial",
  #  id = "id",
  weights = df_clean$t0_sample_weights,
  learners_trt = sl_lib,
  learners_outcome = sl_lib 
)

here_save(m_time_community_null, "m_time_community_null")
m_time_community_null
contrast_time_commmunity_full <- lmtp_contrast(m_time_community,ref = m_time_community_null, type = "rr")
contrast_time_commmunity_full


m_time_friends <- lmtp_tmle(
  data = df_clean,
  trt = A,
  baseline = names_base,
  outcome = "t2_friends_time_binary",
  cens = C,
  shift = f,
  mtp = TRUE,
  folds = 5,
  # trim = 0.99, # if needed
  # time_vary = NULL,
  outcome_type = "binomial",
  #  id = "id",
  weights = df_clean$t0_sample_weights,
  learners_trt = sl_lib,
  learners_outcome = sl_lib 
)

m_time_friends
here_save(m_time_friends, "m_time_friends")

m_time_friends_null <- lmtp_tmle(
  data = df_clean,
  trt = A,
  baseline = names_base,
  outcome = "t2_friends_time_binary",
  cens = C,
  shift = NULL,
  mtp = FALSE,
  folds = 5,
  # trim = 0.99, # if needed
  # time_vary = NULL,
  outcome_type = "binomial",
  #  id = "id",
  weights = df_clean$t0_sample_weights,
  learners_trt = sl_lib,
  learners_outcome = sl_lib 
)

here_save(m_time_friends_null, "m_time_friends_null")
m_time_friends_null



m_time_family <- lmtp_tmle(
  data = df_clean,
  trt = A,
  baseline = names_base,
  outcome = "t2_family_time_binary",
  cens = C,
  shift = f,
  mtp = TRUE,
  folds = 5,
  # trim = 0.99, # if needed
  # time_vary = NULL,
  outcome_type = "binomial",
  #  id = "id",
  weights = df_clean$t0_sample_weights,
  learners_trt = sl_lib,
  learners_outcome = sl_lib 
)

m_time_family
here_save(m_time_family, "m_time_family")

m_time_family_null <- lmtp_tmle(
  data = df_clean,
  trt = A,
  baseline = names_base,
  outcome = "t2_family_time_binary",
  cens = C,
  shift = NULL,
  mtp = FALSE,
  folds = 5,
  # trim = 0.99, # if needed
  # time_vary = NULL,
  outcome_type = "binomial",
  #  id = "id",
  weights = df_clean$t0_sample_weights,
  learners_trt = sl_lib,
  learners_outcome = sl_lib 
)

here_save(m_time_family_null, "m_time_family_null")
m_time_family_null


contrast_time_community_full <- lmtp_contrast(m_time_community,ref = m_time_community_null, type = "rr")
contrast_time_community_full

contrast_time_friends_full <- lmtp_contrast(m_time_friends,ref = m_time_friends_null, type = "rr")
contrast_time_friends_full

contrast_time_family_full <- lmtp_contrast(m_time_family,ref = m_time_family_null, type = "rr")
contrast_time_family_full


church_four_hours <- margot_tab_lmtp(contrast_time_commmunity_full, scale = "RD", new_name = "LMTP + 4")
grouped_outcomes <- group_tab( contrast_hours_full, contrast_hours_full,  scale = "RD") 

```

```{r}

#sd(df_wide_censored_donate$t2_charity_donate, na.rm=TRUE) * .0175

church_four_hours_donate <- margot_tab_lmtp(contrast_donate_full, scale = "RD", new_name = "LMTP + 4")

str(church_four_hours_donate)
church_four_hours_donate

est_donate <- sapply(church_four_hours_donate, round, 0)

est_donate
rounded_donate |> 
  kbl(format = "markdown")
# calculate proportion 4 or greater
proportion = sum(df_clean_donate$t1_religion_church_round >= 4) / nrow(df_clean_donate)
proportion
 
theta_donate <- contrast_donate$vals$theta
theta_donate
# adult population 
nz_adult_population = 3989000


# # min wage workers 
# min_wage_2023 = 22.70

# off the cuff
dollars_donate_gained = theta_donate * nz_adult_population
dollars_donate_gained

min_donate_gained =  430 
min_donate_gained
# 832193252
hours_volunteering_gained
```


## TIME
 
```{r}
# analysis for time
df_wide_censored_only_time <-
  prep_coop_all |>
  select(-t1_religion_church_round) |>  # exposure for negative control model
  mutate(
    t0_eth_cat = as.factor(t0_eth_cat),
    t2_family_time_binary = as.integer(ifelse(t2_family_time > 0, 1, 0)),
    t2_friends_time_binary = as.integer(ifelse(t2_friends_time > 0, 1, 0)),
    t2_community_time_binary = as.integer(ifelse(t2_community_time > 0, 1, 0))
  ) |>
  relocate("t0_not_censored", .before = starts_with("t1_"))  %>%
  relocate("t1_not_censored", .before = starts_with("t2_"))
    

# save
here_save(df_wide_censored_only_time, "df_wide_censored_only_time")


#(df_wide_censored_only_time$t1_hours_community_sqrt_round)
# 2.5*sd(df_clean$t1_religion_church_round)
# 2.5*sd(df_wide_censored_only_time$t1_hours_community_sqrt_round)
# hist(df_wide_censored_only_time$t1_hours_community_sqrt_round)

# spit and shine
df_clean_time <- df_wide_censored_only_time %>%
  mutate(t2_na_flag = rowSums(is.na(select(
    ., starts_with("t2_")
  ))) > 0) %>%
  mutate(t1_not_censored = ifelse(t2_na_flag, 0, t1_not_censored)) %>%
  # select(-t2_na_flag) %>%
  filter(!rowSums(is.na(select(
    ., starts_with("t0_")
  )))) |>
  dplyr::mutate(
    across(
      where(is.numeric) &
        !t0_not_censored &
        !t1_not_censored &
        !t0_hours_family_sqrt_round &
        !t0_hours_friends_sqrt_round &
        !t0_hours_community_sqrt_round &
        !t0_sample_weights &
        !t1_hours_community_sqrt_round &
        !t2_charity_donate &
        !t2_family_time_binary &
        !t2_friends_time_binary &
        !t2_community_time_binary &
        !t2_gratitude &
        !t2_hours_charity,
      ~ scale(.x),
      .names = "{col}_z"
    )
  ) |>
  select(
    where(is.factor),
    t0_not_censored,
    t0_hours_family_sqrt_round,
    t0_hours_friends_sqrt_round,
    t0_hours_community_sqrt_round,
    t0_sample_weights,
    t1_not_censored,
    t1_hours_community_sqrt_round,
    t2_gratitude,
    t2_charity_donate,
    t2_hours_charity,
    t2_family_time_binary,
    t2_friends_time_binary,
    t2_community_time_binary,
    ends_with("_z")
  ) |>
  relocate(starts_with("t0_"), .before = starts_with("t1_"))  %>%
  relocate(starts_with("t2_"), .after = starts_with("t1_"))  %>%
  relocate("t0_not_censored", .before = starts_with("t1_"))  %>%
  relocate("t1_not_censored", .before = starts_with("t2_")) |>
  mutate(t0_sample_weights = as.numeric(t0_sample_weights)) |>
  data.frame()

naniar::vis_miss(df_clean_time, warn_large_data = FALSE)
#dev.off()

# save data
push_mods
here_save(df_clean_time,"df_clean_time")
df_clean_time <-here_read("df_clean_time")

colnames(df_clean)
# get names
names_base_time <- df_clean_time |> select( starts_with("t0"), - t0_sample_weights,-t0_not_censored )|> colnames()
names_outcomes_time <- df_clean_time|> select( starts_with("t2"))|> colnames()

names_base_time
names_outcomes_time
names_base_time

#  model
A <- c("t1_hours_community_sqrt_round")
C <- c( "t1_not_censored")

#L <- list(c("L1"), c("L2")) 
W <- c(paste(names_base_time, collapse = ", "))

# check 
print(W) 


#baseline confounders
#L <- as.list(names_base)
table(df_clean_time$t1_hours_community_sqrt_round)

# shift function -- what if everyone increased by .5 standard deviation, except those above 2 

# simple shift, everyone goes to church at least 4 times per week
f <- function(data, trt){
  ifelse( data[[trt]] <=2, 2,  data[[trt]] )
}

# f_1 <- function (data, trt) data[[trt]] + 1
 

# Create a vector indicating what algorithms should be R. # used in the SuperLearner 

# libraries
library(SuperLearner)
library(xgboost)


# "SL.earth" refers to a wrapper for the 'earth' function from the 'earth' R package in the SuperLearner library. This function implements Multivariate Adaptive Regression Splines (MARS), a non-parametric regression method that extends linear models by allowing for interactions and non-linear relationships between variables.
# MARS models can handle high-dimensional data well and can be a useful tool for capturing complex patterns in the data. They work by fitting piecewise linear models to the data, which allows for flexible and potentially non-linear relationships between predictors and the outcome.

# super learner libraries
sl_lib <- c("SL.glmnet", 
           "SL.ranger", # faster implementation of random forest
           "SL.earth") #


# BONUS: progressr progress bars!
progressr::handlers(global = TRUE)

# we will only assess behaviour 
names_outcomes
# recomend tmle for single time point
# recommend sdr for multiple time points
f
A
C

df<- df_clean_time

names_base<- names_base_time

# model charitable giving in population 
m_hours_charity_time <- lmtp_tmle(
  data = df,
  trt = A,
  baseline = names_base,
  outcome = "t2_hours_charity",
  cens = C,
  shift = f,
  mtp = TRUE,
  folds = 5,
  # trim = 0.99, # if needed
  # time_vary = NULL,
  outcome_type = "continuous",
  #  id = "id",
  weights = df$t0_sample_weights,
  learners_trt = sl_lib,
  learners_outcome = sl_lib 
)
m_hours_charity_time
here_save(m_hours_charity_time, "m_hours_charity_time")
m_hours_charity_time <- here_read("m_hours_charity_time")
m_hours_charity_time
m_hours_charity_null_time <- lmtp_tmle(
  data = df,
  trt = A,
  baseline = names_base,
  outcome = "t2_hours_charity",
  cens = C,
  shift = NULL,
 # mtp = TRUE,
  folds = 5,
  # trim = 0.99, # if needed
  # time_vary = NULL,
  outcome_type = "continuous",
  #  id = "id",
  weights = df$t0_sample_weights,
  learners_trt = sl_lib,
  learners_outcome = sl_lib 
)
m_hours_charity_null_time
here_save(m_hours_charity_null_time, "m_hours_charity_null_time")
m_hours_charity_null_time <- here_read( "m_hours_charity_null_time")
m_hours_charity_null_time
# caluclate contrast 
contrast_hours_full_time <- lmtp_contrast(m_hours_charity_time,ref = m_hours_charity_null_time, type = "additive")
str(contrast_hours_full_time)
contrast_hours_full_time

# min_wage_2022 = 21.20
# nz_adult_population = 3989000
# 
# hours_amount = .406 *min_wage_2022
# hours_amount
# year_hours = hours_amount * 52
# year_hours
# sum_hours = year_hours * nz_adult_population
# 
# sum_hours 
# sum_hours/(nz_annual_budget*4)
# 
# 0.007698764
# 
# # nz annual budget in 2021
# nz_annual_budget = 14494000000 * 4
# nz_annual_budget
# 1,785,374,282
# 
# charity_year = 1715270000
# hours_year = 1785374282
# 
# charity_year/nz_annual_budget
# (charity_year +hours_year)/nz_annual_budget


# not right
church_four_time <- format_tab_tmle(church_four_time, scale = "RD", new_name = "church_four")
church_four_time

# 
# margot_tab_lmtp <- function(tmtp_output, scale = c("RD", "RR"), new_name = "character_string") {
# 
#   scale <- match.arg(scale)
# 
#   require(dplyr)
# 
#   tab_tmle <- cbind.data.frame(
#     tmtp_output$vals$theta,
#     tmtp_output$vals$std.error,
#     tmtp_output$vals$conf.low,
#     tmtp_output$vals$conf.high
#   )
# 
#   if (scale == "RD") {
#     colnames(tab_tmle) <- c("E[Y(1)]-E[Y(0)]", "standard_error", "2.5 %", "97.5 %")
#   } else if (scale == "RR") {
#     colnames(tab_tmle) <- c("E[Y(1)]/E[Y(0)]", "standard_error", "2.5 %", "97.5 %")
#   }
# 
#   tab_tmle_round <- tab_tmle |>
#     dplyr::mutate(across(where(is.numeric), round, digits = 4))
# 
#   rownames(tab_tmle_round)[1] <- paste0(new_name)
# 
#   return(tab_tmle_round)
# }

# 
# theta <- contrast_hours_full$vals$theta
# # adult population
# nz_adult_population = 3989000
# 
# # min wage workers 
# min_wage_2023 = 22.70
# 
# # off the cuff
# hours_volunteering_gained = theta * nz_adult_population
# hours_volunteering_gained
# 
# # cash value of intervention
# hours_volunteering_gained * min_wage_2022
# 
# 
# ## donation model 
# t2_charity_donate

m_charity_donate_time <- lmtp_tmle(
  data = df,
  trt = A,
  baseline = names_base,
  outcome = "t2_charity_donate",
  cens = C,
  shift = f,
  mtp = TRUE,
  folds = 5,
  # trim = 0.99, # if needed
  # time_vary = NULL,
  outcome_type = "continuous",
  #  id = "id",
  weights = df$t0_sample_weights,
  learners_trt = sl_lib,
  learners_outcome = sl_lib 
)
here_save(m_charity_donate_time, "m_charity_donate_time")
m_charity_donate_time <- here_read("m_charity_donate_time")
m_charity_donate_time

# under null
m_charity_donate_null_time <- lmtp_tmle(
  data = df,
  trt = A,
  baseline = names_base,
  outcome = "t2_charity_donate",
  cens = C,
  shift = NULL,
  mtp = FALSE,
  folds = 5,
  # trim = 0.99, # if needed
  # time_vary = NULL,
  outcome_type = "continuous",
  #  id = "id",
  weights = df$t0_sample_weights,
  learners_trt = sl_lib,
  learners_outcome = sl_lib 
)

here_save(m_charity_donate_null_time, "m_charity_donate_null_time")
m_charity_donate_null_time<- here_read( "m_charity_donate_null_time")
m_charity_donate_null_time
m_charity_donate_null_time
contrast_donate_full_time <- lmtp_contrast(m_charity_donate_time,ref = m_charity_donate_null_time, type = "additive")
contrast_donate_full_time


m_time_community_time <- lmtp_tmle(
  data = df,
  trt = A,
  baseline = names_base,
  outcome = "t2_community_time_binary",
  cens = C,
  shift = f,
  mtp = TRUE,
  folds = 5,
  # trim = 0.99, # if needed
  # time_vary = NULL,
  outcome_type = "binomial",
  #  id = "id",
  weights = df$t0_sample_weights,
  learners_trt = sl_lib,
  learners_outcome = sl_lib 
)
m_time_community_time
here_save(m_time_community_time, "m_time_community_time")
m_time_community_time <- here_read("m_time_community_time")
m_time_community_time

m_time_community_null_time <- lmtp_tmle(
  data = df,
  trt = A,
  baseline = names_base,
  outcome = "t2_community_time_binary",
  cens = C,
  shift = NULL,
  mtp = FALSE,
  folds = 5,
  # trim = 0.99, # if needed
  # time_vary = NULL,
  outcome_type = "binomial",
  #  id = "id",
  weights = df$t0_sample_weights,
  learners_trt = sl_lib,
  learners_outcome = sl_lib 
)

here_save(m_time_community_null_time, "m_time_community_null_time")
m_time_community_null_time <- here_read( "m_time_community_null_time")

m_time_community_null_time

contrast_time_commmunity_full_time <- lmtp_contrast(m_time_community_time,ref = m_time_community_null_time, type = "rr")
contrast_time_commmunity_full_time


m_time_friends_time <- lmtp_tmle(
  data = df,
  trt = A,
  baseline = names_base,
  outcome = "t2_friends_time_binary",
  cens = C,
  shift = f,
  mtp = TRUE,
  folds = 5,
  # trim = 0.99, # if needed
  # time_vary = NULL,
  outcome_type = "binomial",
  #  id = "id",
  weights = df$t0_sample_weights,
  learners_trt = sl_lib,
  learners_outcome = sl_lib 
)

m_time_friends_time
here_save(m_time_friends_time, "m_time_friends_time")
m_time_friends_time <- here_read("m_time_friends_time")


m_time_friends_null_time <- lmtp_tmle(
  data = df,
  trt = A,
  baseline = names_base,
  outcome = "t2_friends_time_binary",
  cens = C,
  shift = NULL,
  mtp = FALSE,
  folds = 5,
  # trim = 0.99, # if needed
  # time_vary = NULL,
  outcome_type = "binomial",
  #  id = "id",
  weights = df$t0_sample_weights,
  learners_trt = sl_lib,
  learners_outcome = sl_lib 
)

here_save(m_time_friends_null_time, "m_time_friends_null_time")
m_time_friends_null_time



m_time_family_time <- lmtp_tmle(
  data = df,
  trt = A,
  baseline = names_base,
  outcome = "t2_family_time_binary",
  cens = C,
  shift = f,
  mtp = TRUE,
  folds = 5,
  # trim = 0.99, # if needed
  # time_vary = NULL,
  outcome_type = "binomial",
  #  id = "id",
  weights = df$t0_sample_weights,
  learners_trt = sl_lib,
  learners_outcome = sl_lib 
)

m_time_family_time
here_save(m_time_family_time, "m_time_family_time")

m_time_family_null_time <- lmtp_tmle(
  data = df,
  trt = A,
  baseline = names_base,
  outcome = "t2_family_time_binary",
  cens = C,
  shift = NULL,
  mtp = FALSE,
  folds = 5,
  # trim = 0.99, # if needed
  # time_vary = NULL,
  outcome_type = "binomial",
  #  id = "id",
  weights = df$t0_sample_weights,
  learners_trt = sl_lib,
  learners_outcome = sl_lib 
)

here_save(m_time_family_null_time, "m_time_family_null_time")
m_time_family_null_time


contrast_time_community_full_time <- lmtp_contrast(m_time_community_time,ref = m_time_community_null_time, type = "rr")
contrast_time_community_full_time

contrast_time_friends_full_time <- lmtp_contrast(m_time_friends_time,ref = m_time_friends_null_time, type = "rr")
contrast_time_friends_full_time

contrast_time_family_full_time <- lmtp_contrast(m_time_family_time,ref = m_time_family_null_time, type = "rr")
contrast_time_family_full_time


church_four_hours_time <- margot_tab_lmtp(contrast_time_commmunity_full_time, scale = "RD", new_name = "LMTP + 4")
grouped_outcomes <- group_tab( contrast_hours_full, contrast_hours_full_time,  scale = "RD") 

```

```{r}
#sd(df_wide_censored_donate$t2_charity_donate, na.rm=TRUE) * .0175
church_four_hours_donate <- margot_tab_lmtp(contrast_donate_full, scale = "RD", new_name = "LMTP + 4")
church_four_hours_donate

str(church_four_hours_donate)
church_four_hours_donate

est_donate <- sapply(church_four_hours_donate, round, 0)

est_donate
rounded_donate |> 
  kbl(format = "markdown")
# calculate proportion 4 or greater
proportion = sum(df_clean_donate$t1_religion_church_round >= 4) / nrow(df_clean_donate)
proportion
 
theta_donate <- contrast_donate$vals$theta
theta_donate
# adult population 
nz_adult_population = 3989000


# # min wage workers 
# min_wage_2023 = 22.70

# off the cuff
dollars_donate_gained = theta_donate * nz_adult_population
dollars_donate_gained

min_donate_gained =  430 
min_donate_gained
# 832193252
hours_volunteering_gained
```




